# Хороші практики у тестуванні

Тестування є ключовим етапом у забезпеченні якості програмного забезпечення. Дотримання хороших практик допомагає створювати тести, які є ефективними, стабільними та простими в підтримці. Нижче наведено список рекомендацій для покращення підходів до тестування.

## 1. Пишіть тести для найбільш важливих частин системи (бізнес-логіки)
Зосередьте зусилля на тестуванні найбільш критичних частин системи, які безпосередньо впливають на бізнес-функціонал.

**Чому це важливо:**
- Забезпечує стабільність ключових компонентів.
- Знижує ризик критичних помилок у виробничому середовищі.

## 2. Використовуйте юніт-тести для покриття граничних випадків та складних сценаріїв
Юніт-тести ефективно перевіряють різні сценарії роботи окремих модулів, включаючи граничні випадки та рідкісні ситуації.

**Чому це важливо:**
- Дозволяє виявити помилки на ранньому етапі.
- Підвищує впевненість у правильності роботи кожного модуля.

**Приклад:**
```kotlin
@Test
fun `should return error for input out of range`() {
    val result = systemUnderTest.processInput(-1)
    assertEquals("ERROR", result)
}
```

## 3. Створюйте тести, які перевіряють кінцевий результат, а не процес виконання
Тести мають перевіряти очікувану поведінку та результати роботи системи, а не деталі її виконання.

**Чому це важливо:**
- Підвищує стійкість тестів до змін у реалізації.

**Приклад:**
```kotlin
@Test
fun `should return correct total amount`() {
    val total = cart.calculateTotal()
    assertEquals(100.0, total)
}
```

## 4. Розділяйте бізнес-логіку та побічні ефекти для спрощення тестування
Розділення логіки та взаємодії з зовнішніми залежностями спрощує написання та підтримку тестів.

**Чому це важливо:**
- Зменшує складність тестування.
- Полегшує ізоляцію та модульність коду.

## 5. Використовуйте підхід 'білого ящика' для аналізу тестів а 'чорного ящика' для написання тестів
Використовуйте утиліти, що показують покриття коду для виявлення непротестованих частин програми,
але потім тестуйте їх так, немов вам нічого не відомо про внутрішню структуру цього коду.


**Чому це важливо:**
- Дозволяє зосередитися на перевірці поведінки системи.
- Забезпечує гнучкість до змін у внутрішній реалізації.

## 6. Забезпечуйте ізоляцію тестів, щоб уникнути залежностей між ними
Кожен тест має бути незалежним від інших і виконуватись у контрольованому середовищі.

**Чому це важливо:**
- Гарантує відтворюваність тестів.
- Зменшує труднощі з пошуком проблем у разі їхнього виникнення.

**Приклад:**
```kotlin
@BeforeEach
fun setup() {
    database.clear()
}
```

## 7. Тестові назви повинні відображати поведінку, а не методи
Іменування тестів має чітко описувати перевірювану поведінку, що робить їх більш зрозумілими для інших розробників.

**Чому це важливо:**
- Полегшує розуміння мети тесту.
- Допомагає швидко знаходити потрібні тести.

**Приклад:**
```kotlin
@Test
fun `should apply discount for VIP customers`() {
    // Тестуємо знижку для VIP-клієнтів
}
```

## 8. Підтримуйте чіткий та мінімалістичний дизайн тестів
Тести мають бути простими та зосередженими на перевірці одного аспекту поведінки.

**Чому це важливо:**
- Полегшує читання та підтримку.
- Зменшує ймовірність помилок у тестах.

**Приклад:**
```kotlin
@Test
fun `should return default value if input is null`() {
    val result = systemUnderTest.processInput(null)
    assertEquals("DEFAULT", result)
}
```

---

**Висновок:** Виконання цих практик допоможе створювати тести, які є ефективними, підтримуваними та стійкими до змін у коді.

